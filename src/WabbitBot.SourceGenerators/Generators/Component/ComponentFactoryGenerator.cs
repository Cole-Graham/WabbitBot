using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using WabbitBot.SourceGenerators.Utils;

namespace WabbitBot.SourceGenerators.Generators.Component;

/// <summary>
/// Generates component factory code for POCO models marked with [GenerateComponentFactory].
/// Scans ComponentModels/ directory and creates factory methods to convert POCOs to Discord components.
/// </summary>
[Generator]
public class ComponentFactoryGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var isDiscBotProject = context.CompilationProvider.IsDiscBot();

        // Pipeline: Find classes with [GenerateComponentFactory] attribute
        var componentClasses = context.SyntaxProvider.CreateSyntaxProvider(
                predicate: (node, _) => node.HasAttribute("GenerateComponentFactory"),
                transform: (ctx, ct) =>
                {
                    ct.ThrowIfCancellationRequested();
                    var classSymbol = ctx.SemanticModel.GetDeclaredSymbol(ctx.Node) as INamedTypeSymbol;
                    if (classSymbol == null)
                        return null;

                    // Extract attribute information
                    var attr = classSymbol.GetAttributes()
                        .FirstOrDefault(a => a.AttributeClass?.Name == "GenerateComponentFactoryAttribute");

                    if (attr == null)
                        return null;

                    var theme = attr.NamedArguments
                        .FirstOrDefault(kvp => kvp.Key == "Theme")
                        .Value.Value as string ?? "Info";

                    var supportsAttachments = attr.NamedArguments
                        .FirstOrDefault(kvp => kvp.Key == "SupportsAttachments")
                        .Value.Value as bool? ?? false;

                    // Check if class has a Container or Embed property
                    var hasContainer = classSymbol.GetMembers()
                        .OfType<IPropertySymbol>()
                        .Any(p => p.Type.Name.Contains("Container"));

                    var hasEmbed = classSymbol.GetMembers()
                        .OfType<IPropertySymbol>()
                        .Any(p => p.Type.Name.Contains("Embed") && p.Name != "EmbedBuilder");

                    return new ComponentModelInfo(
                        classSymbol.Name,
                        classSymbol.ContainingNamespace.ToDisplayString(),
                        theme,
                        supportsAttachments,
                        hasContainer,
                        hasEmbed);
                })
            .Where(info => info != null)
            .Collect();

        // Generate factory class
        context.RegisterSourceOutput(componentClasses.Combine(isDiscBotProject), (spc, tuple) =>
        {
            var (models, isDiscBot) = tuple;
            if (!isDiscBot || !models.Any())
                return;

            var source = GenerateFactory(models.Where(m => m != null).ToList()!);
            spc.AddSource("ComponentFactories.g.cs", source);
        });
    }

    private SourceText GenerateFactory(List<ComponentModelInfo> models)
    {
        var buildMethods = new StringBuilder();

        foreach (var model in models)
        {
            buildMethods.AppendLine(GenerateBuildMethod(model));
            buildMethods.AppendLine();
        }

        var content = $$"""
            // <auto-generated />
            // This file was generated by ComponentFactoryGenerator
            // DO NOT EDIT - Changes will be overwritten

            using System;
            using DSharpPlus.Entities;
            using WabbitBot.DiscBot.DSharpPlus.ComponentModels;

            namespace WabbitBot.DiscBot.DSharpPlus.Factories
            {
                /// <summary>
                /// Factory for building Discord components from POCO models.
                /// Generated at compile time from component models in ComponentModels/.
                /// </summary>
                public static class ComponentFactory
                {
            {{SourceEmitter.Indent(buildMethods.ToString(), 2)}}
                }
            }
            """;

        return SourceText.From(content, Encoding.UTF8);
    }

    private string GenerateBuildMethod(ComponentModelInfo model)
    {
        var methodName = $"Build{model.ClassName}";
        var returnType = "VisualBuildResult";

        // Generate method body based on pattern (Container vs Embed)
        var body = model.HasContainer
            ? "return VisualBuildResult.FromContainer(model.ComponentType, attachment: null);"
            : throw new InvalidOperationException($"Component model {model.ClassName} must have a Container property");

        var sb = new StringBuilder();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine($"        /// Builds a visual component from a {model.ClassName} model.");
        sb.AppendLine("        /// Returns a Container-based result (current standard).");
        if (!string.IsNullOrEmpty(model.Theme))
        {
            sb.AppendLine($"        /// Theme: {model.Theme}");
        }
        if (model.SupportsAttachments)
        {
            sb.AppendLine("        /// Supports attachments.");
        }
        sb.AppendLine("        /// </summary>");
        sb.AppendLine($"        /// <param name=\"model\">The {model.ClassName} instance to build from</param>");
        sb.AppendLine("        /// <returns>A visual build result containing the container component</returns>");
        sb.AppendLine($"        public static {returnType} {methodName}({model.ClassName} model)");
        sb.AppendLine("        {");
        sb.AppendLine("            ArgumentNullException.ThrowIfNull(model);");
        sb.AppendLine($"            {body}");
        sb.Append("        }");

        return sb.ToString();
    }
}

/// <summary>
/// Information about a component model class.
/// </summary>
internal record ComponentModelInfo(
    string ClassName,
    string Namespace,
    string Theme,
    bool SupportsAttachments,
    bool HasContainer,
    bool HasEmbed);

