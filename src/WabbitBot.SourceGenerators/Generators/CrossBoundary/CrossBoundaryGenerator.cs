using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using WabbitBot.SourceGenerators.Utils;

namespace WabbitBot.SourceGenerators.Generators.CrossBoundary;

public enum CrossBoundaryDirection
{
    CoreToDiscBot,
    DiscBotToCore
}

[Generator]
public class CrossBoundaryGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Pipeline for Core to DiscBot types
        var coreToDiscBotTypes = context.SyntaxProvider.CreateSyntaxProvider(
            predicate: (node, _) => node.HasAttribute("GenerateCoreToDiscBot"),
            transform: (ctx, ct) =>
            {
                ct.ThrowIfCancellationRequested();
                return ctx.Node as TypeDeclarationSyntax;
            })
            .Where(type => type != null)
            .Collect();

        // Pipeline for DiscBot to Core types
        var discBotToCoreTypes = context.SyntaxProvider.CreateSyntaxProvider(
            predicate: (node, _) => node.HasAttribute("GenerateDiscBotToCore"),
            transform: (ctx, ct) =>
            {
                ct.ThrowIfCancellationRequested();
                return ctx.Node as TypeDeclarationSyntax;
            })
            .Where(type => type != null)
            .Collect();

        // Combine with compilation info
        var compilationInfo = context.CompilationProvider.Select((comp, ct) => comp.AssemblyName);

        // Generate Core to DiscBot classes
        var coreToDiscBotSource = coreToDiscBotTypes
            .Combine(compilationInfo)
            .Select((combined, ct) =>
            {
                ct.ThrowIfCancellationRequested();
                var (types, assemblyName) = combined;
                if (assemblyName?.Contains("DiscBot") == true && types.Any())
                {
                    var sourceText = GenerateCrossBoundaryClasses(types.Where(t => t != null).Cast<TypeDeclarationSyntax>().ToList(), CrossBoundaryDirection.CoreToDiscBot);
                    return sourceText;
                }
                return SourceText.From("", Encoding.UTF8);
            });

        // Generate DiscBot to Core classes
        var discBotToCoreSource = discBotToCoreTypes
            .Combine(compilationInfo)
            .Select((combined, ct) =>
            {
                ct.ThrowIfCancellationRequested();
                var (types, assemblyName) = combined;
                if (assemblyName?.Contains("Core") == true && types.Any())
                {
                    var sourceText = GenerateCrossBoundaryClasses(types.Where(t => t != null).Cast<TypeDeclarationSyntax>().ToList(), CrossBoundaryDirection.DiscBotToCore);
                    return sourceText;
                }
                return SourceText.From("", Encoding.UTF8);
            });

        context.RegisterSourceOutput(coreToDiscBotSource, (spc, source) =>
        {
            if (!string.IsNullOrEmpty(source.ToString()))
                spc.AddSource("CoreToDiscBotClasses.g.cs", source);
        });

        context.RegisterSourceOutput(discBotToCoreSource, (spc, source) =>
        {
            if (!string.IsNullOrEmpty(source.ToString()))
                spc.AddSource("DiscBotToCoreClasses.g.cs", source);
        });
    }

    private SourceText GenerateCrossBoundaryClasses(List<TypeDeclarationSyntax> types, CrossBoundaryDirection direction)
    {
        var sourceBuilder = new StringBuilder();

        // Add file header
        sourceBuilder.AppendLine("// <auto-generated />");
        sourceBuilder.AppendLine("// This file is generated by the CrossBoundaryGenerator.");
        sourceBuilder.AppendLine("// Changes to this file will be overwritten.");
        sourceBuilder.AppendLine();
        sourceBuilder.AppendLine("#nullable enable");
        sourceBuilder.AppendLine();
        sourceBuilder.AppendLine("using System;");
        sourceBuilder.AppendLine("using System.Collections.Generic;");
        sourceBuilder.AppendLine("using WabbitBot.Common.Attributes;");
        sourceBuilder.AppendLine("using WabbitBot.Common.Events.EventInterfaces;");
        sourceBuilder.AppendLine("using WabbitBot.Common.Models;");
        sourceBuilder.AppendLine();

        // Determine target namespace based on direction
        var targetNamespace = GetTargetNamespace(direction);
        sourceBuilder.AppendLine($"namespace {targetNamespace}");
        sourceBuilder.AppendLine("{");

        foreach (var typeDeclaration in types)
        {
            var typeSource = GenerateEventTypeDefinition(typeDeclaration);
            sourceBuilder.AppendLine(typeSource);
            sourceBuilder.AppendLine();
        }

        sourceBuilder.AppendLine("}");

        return SourceText.From(sourceBuilder.ToString(), Encoding.UTF8);
    }

    private string GetTargetNamespace(CrossBoundaryDirection direction)
    {
        return direction switch
        {
            CrossBoundaryDirection.CoreToDiscBot => "WabbitBot.DiscBot.Generated.Events",
            CrossBoundaryDirection.DiscBotToCore => "WabbitBot.Core.Generated.CrossBoundary",
            _ => "WabbitBot.Common.Generated.Events"
        };
    }

    private string GenerateEventTypeDefinition(TypeDeclarationSyntax typeDeclaration)
    {
        var typeName = typeDeclaration.Identifier.Text;
        var modifiers = typeDeclaration.Modifiers.ToString();
        var keyword = typeDeclaration.Keyword.Text; // class, struct, enum, etc.

        var sourceBuilder = new StringBuilder();

        // Generate event type declaration - all cross-boundary events implement IEvent
        sourceBuilder.Append($"    {modifiers} {keyword} {typeName} : IEvent");
        sourceBuilder.AppendLine();
        sourceBuilder.AppendLine("    {");

        // Add IEvent implementation properties
        sourceBuilder.AppendLine("        public EventBusType EventBusType { get; init; } = EventBusType.Global;");
        sourceBuilder.AppendLine("        public Guid EventId { get; init; } = Guid.NewGuid();");
        sourceBuilder.AppendLine("        public DateTime Timestamp { get; init; } = DateTime.UtcNow;");

        // Generate original members (properties only)
        foreach (var member in typeDeclaration.Members)
        {
            if (member is PropertyDeclarationSyntax property)
            {
                var propertyText = property.ToFullString().Trim();
                // Remove the original indentation and add consistent indentation
                var lines = propertyText.Split('\n');
                foreach (var line in lines)
                {
                    if (!string.IsNullOrWhiteSpace(line))
                    {
                        sourceBuilder.AppendLine($"        {line.Trim()}");
                    }
                }
            }
        }

        sourceBuilder.AppendLine("    }");

        return sourceBuilder.ToString();
    }
}

