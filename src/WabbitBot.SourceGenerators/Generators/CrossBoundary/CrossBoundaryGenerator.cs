using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Text;

namespace WabbitBot.SourceGenerators.Generators.CrossBoundary;

public enum CrossBoundaryDirection
{
    CoreToDiscBot,
    DiscBotToCore
}

[Generator]
public class CrossBoundaryGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new CrossBoundarySyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not CrossBoundarySyntaxReceiver receiver)
            return;

        if (!receiver.CoreToDiscBotTypes.Any() && !receiver.DiscBotToCoreTypes.Any())
            return;

        var assemblyName = context.Compilation.AssemblyName;

        // Handle Core to DiscBot generation
        if (assemblyName?.Contains("DiscBot") == true && receiver.CoreToDiscBotTypes.Any())
        {
            var sourceBuilder = GenerateCrossBoundaryClasses(receiver.CoreToDiscBotTypes, context, CrossBoundaryDirection.CoreToDiscBot);
            var fileName = "CoreToDiscBotClasses.g.cs";
            var sourceText = sourceBuilder.ToString();
            context.AddSource(fileName, sourceText);
        }

        // Handle DiscBot to Core generation
        if (assemblyName?.Contains("Core") == true && receiver.DiscBotToCoreTypes.Any())
        {
            var sourceBuilder = GenerateCrossBoundaryClasses(receiver.DiscBotToCoreTypes, context, CrossBoundaryDirection.DiscBotToCore);
            var fileName = "DiscBotToCoreClasses.g.cs";
            var sourceText = sourceBuilder.ToString();
            context.AddSource(fileName, sourceText);
        }
    }

    private StringBuilder GenerateCrossBoundaryClasses(List<TypeDeclarationSyntax> types, GeneratorExecutionContext context, CrossBoundaryDirection direction)
    {
        var sourceBuilder = new StringBuilder();

        // Add file header
        sourceBuilder.AppendLine("// <auto-generated />");
        sourceBuilder.AppendLine("// This file is generated by the CrossBoundaryGenerator.");
        sourceBuilder.AppendLine("// Changes to this file will be overwritten.");
        sourceBuilder.AppendLine();
        sourceBuilder.AppendLine("#nullable enable");
        sourceBuilder.AppendLine();
        sourceBuilder.AppendLine("using System;");
        sourceBuilder.AppendLine("using System.Collections.Generic;");
        sourceBuilder.AppendLine("using WabbitBot.Common.Attributes;");
        sourceBuilder.AppendLine("using WabbitBot.Common.Events.EventInterfaces;");
        sourceBuilder.AppendLine("using WabbitBot.Common.Models;");
        sourceBuilder.AppendLine();

        // Determine target namespace based on compilation and direction
        var targetNamespace = GetTargetNamespace(context, direction);
        sourceBuilder.AppendLine($"namespace {targetNamespace}");
        sourceBuilder.AppendLine("{");

        foreach (var typeDeclaration in types)
        {
            var typeSource = GenerateEventTypeDefinition(typeDeclaration, context);
            sourceBuilder.AppendLine(typeSource);
            sourceBuilder.AppendLine();
        }

        sourceBuilder.AppendLine("}");

        return sourceBuilder;
    }

    private string GetTargetNamespace(GeneratorExecutionContext context, CrossBoundaryDirection direction)
    {
        // Check if we're generating for DiscBot
        var assemblyName = context.Compilation.AssemblyName;
        if (assemblyName?.Contains("DiscBot") == true)
        {
            return direction switch
            {
                CrossBoundaryDirection.CoreToDiscBot => "WabbitBot.DiscBot.Generated.Events",
                _ => "WabbitBot.DiscBot.Generated.Events"
            };
        }

        // When generating in Core, use a namespace that won't conflict
        if (assemblyName?.Contains("Core") == true)
        {
            return direction switch
            {
                CrossBoundaryDirection.DiscBotToCore => "WabbitBot.Core.Generated.CrossBoundary",
                _ => "WabbitBot.Core.Generated.CrossBoundary"
            };
        }

        // Default fallback
        return "WabbitBot.Common.Generated.Events";
    }

    private string GenerateEventTypeDefinition(TypeDeclarationSyntax typeDeclaration, GeneratorExecutionContext context)
    {
        var typeName = typeDeclaration.Identifier.Text;
        var modifiers = typeDeclaration.Modifiers.ToString();
        var keyword = typeDeclaration.Keyword.Text; // class, struct, enum, etc.

        var sourceBuilder = new StringBuilder();

        // Generate event type declaration - all cross-boundary events implement IEvent
        sourceBuilder.Append($"    {modifiers} {keyword} {typeName} : IEvent");
        sourceBuilder.AppendLine();
        sourceBuilder.AppendLine("    {");

        // Add IEvent implementation properties
        sourceBuilder.AppendLine("        public EventBusType EventBusType { get; init; } = EventBusType.Global;");
        sourceBuilder.AppendLine("        public string EventId { get; init; } = Guid.NewGuid().ToString();");
        sourceBuilder.AppendLine("        public DateTime Timestamp { get; init; } = DateTime.UtcNow;");

        // Generate original members (properties only)
        foreach (var member in typeDeclaration.Members)
        {
            if (member is PropertyDeclarationSyntax property)
            {
                var propertyText = property.ToFullString().Trim();
                // Remove the original indentation and add consistent indentation
                var lines = propertyText.Split('\n');
                foreach (var line in lines)
                {
                    if (!string.IsNullOrWhiteSpace(line))
                    {
                        sourceBuilder.AppendLine($"        {line.Trim()}");
                    }
                }
            }
        }

        sourceBuilder.AppendLine("    }");

        return sourceBuilder.ToString();
    }
}

public class CrossBoundarySyntaxReceiver : ISyntaxReceiver
{
    public List<TypeDeclarationSyntax> CoreToDiscBotTypes { get; } = new();
    public List<TypeDeclarationSyntax> DiscBotToCoreTypes { get; } = new();

    public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
    {
        if (syntaxNode is TypeDeclarationSyntax typeDeclaration)
        {
            var attributeType = GetCrossBoundaryAttributeType(typeDeclaration);
            switch (attributeType)
            {
                case CrossBoundaryAttributeType.CoreToDiscBot:
                    CoreToDiscBotTypes.Add(typeDeclaration);
                    break;
                case CrossBoundaryAttributeType.DiscBotToCore:
                    DiscBotToCoreTypes.Add(typeDeclaration);
                    break;
            }
        }
    }

    private CrossBoundaryAttributeType GetCrossBoundaryAttributeType(TypeDeclarationSyntax typeDeclaration)
    {
        var attributes = typeDeclaration.AttributeLists
            .SelectMany(attrList => attrList.Attributes);

        foreach (var attr in attributes)
        {
            var attrName = attr.Name.ToString();

            // Check for new attributes first
            if (attrName.Contains("GenerateCoreToDiscBot") ||
                attrName.EndsWith("GenerateCoreToDiscBot") ||
                attrName.EndsWith("GenerateCoreToDiscBotAttribute"))
            {
                return CrossBoundaryAttributeType.CoreToDiscBot;
            }

            if (attrName.Contains("GenerateDiscBotToCore") ||
                attrName.EndsWith("GenerateDiscBotToCore") ||
                attrName.EndsWith("GenerateDiscBotToCoreAttribute"))
            {
                return CrossBoundaryAttributeType.DiscBotToCore;
            }

        }

        return CrossBoundaryAttributeType.None;
    }
}

public enum CrossBoundaryAttributeType
{
    None,
    CoreToDiscBot,
    DiscBotToCore
}
