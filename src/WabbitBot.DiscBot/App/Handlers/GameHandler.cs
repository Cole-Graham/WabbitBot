using DSharpPlus;
using DSharpPlus.Entities;
using DSharpPlus.EventArgs;
using WabbitBot.Common.Attributes;
using WabbitBot.Common.Data.Interfaces;
using WabbitBot.Common.Models;
using WabbitBot.Core.Common.Models.Common;
using WabbitBot.Core.Common.Services;
using WabbitBot.DiscBot.App.Events;
using WabbitBot.DiscBot.App.Services.DiscBot;

/// <summary>
/// Handles button and component interactions for game flows.
/// Publishes DiscBot-local interaction events to the event bus.
/// Also handles game-related "Requested" events and calls appropriate Renderer methods.
/// </summary>
namespace WabbitBot.DiscBot.App.Handlers
{
    /// <summary>
    /// Handles button and component interactions for game flows.
    /// Publishes DiscBot-local interaction events to the event bus.
    /// Also handles game-related "Requested" events and calls appropriate Renderer methods.
    /// </summary>
    public partial class GameHandler
    {
        // Initialize() method for subs is to be generated by EventGenerator

        /// <summary>
        /// Handles button interactions.
        /// Returns Result indicating success/failure for immediate feedback.
        /// Publishes events for cross-boundary communication.
        /// </summary>
        public static async Task<Result> HandleButtonInteractionAsync(
            DiscordClient client,
            ComponentInteractionCreatedEventArgs args
        )
        {
            var interaction = args.Interaction;
            var customId = interaction.Data.CustomId;

            try
            {
                // Deck confirmation button
                if (customId.StartsWith("confirm_deck_", StringComparison.Ordinal))
                {
                    return await HandleDeckConfirmAsync(interaction, customId);
                }

                return Result.Failure($"Unknown custom ID: {customId}");
            }
            catch (Exception ex)
            {
                await DiscBotService.ErrorHandler.CaptureAsync(
                    ex,
                    $"Failed to handle button interaction: {customId}",
                    nameof(HandleButtonInteractionAsync)
                );

                // Try to respond with error - may fail if response was already sent
                try
                {
                    await interaction.CreateResponseAsync(
                        DiscordInteractionResponseType.ChannelMessageWithSource,
                        new DiscordInteractionResponseBuilder()
                            .WithContent("An error occurred while processing your interaction. Please try again.")
                            .AsEphemeral()
                    );
                }
                catch
                {
                    // Response was already sent, ignore
                }

                return Result.Failure($"Failed to handle button interaction: {ex.Message}");
            }
        }

        /// <summary>
        /// Handles string select dropdown interactions (map ban selections).
        /// Returns Result indicating success/failure for immediate feedback.
        /// </summary>
        public static async Task<Result> HandleSelectMenuInteractionAsync(
            DiscordClient client,
            ComponentInteractionCreatedEventArgs args
        )
        {
            var interaction = args.Interaction;
            var customId = interaction.Data.CustomId;

            try
            {
                // Placeholder, add select menu interactions here
                return Result.CreateSuccess("No select menu handlers registered");
            }
            catch (Exception ex)
            {
                await DiscBotService.ErrorHandler.CaptureAsync(
                    ex,
                    $"Failed to handle select menu interaction: {customId}",
                    nameof(HandleSelectMenuInteractionAsync)
                );

                // Try to respond with error - may fail if response was already sent
                try
                {
                    await interaction.CreateResponseAsync(
                        DiscordInteractionResponseType.ChannelMessageWithSource,
                        new DiscordInteractionResponseBuilder()
                            .WithContent("An error occurred while processing your selection. Please try again.")
                            .AsEphemeral()
                    );
                }
                catch
                {
                    // Response was already sent, ignore
                }

                return Result.Failure($"Failed to handle select menu interaction: {ex.Message}");
            }
        }

        /// <summary>
        /// Handles modal submissions (deck code input).
        /// Returns Result indicating success/failure for immediate feedback.
        /// Publishes events for cross-boundary communication.
        /// </summary>
        public static async Task<Result> HandleModalSubmitAsync(DiscordClient client, ModalSubmittedEventArgs args)
        {
            var interaction = args.Interaction;
            var customId = interaction.Data.CustomId;

            try
            {
                // Deck code submission modal
                if (customId.StartsWith("submit_deck_", StringComparison.Ordinal))
                {
                    return await HandleDeckSubmissionAsync(interaction, customId);
                }

                return Result.Failure($"Unknown custom ID: {customId}");
            }
            catch (Exception ex)
            {
                await DiscBotService.ErrorHandler.CaptureAsync(
                    ex,
                    $"Failed to handle modal submission: {customId}",
                    nameof(HandleModalSubmitAsync)
                );

                // Try to respond with error - may fail if response was already sent
                try
                {
                    await interaction.CreateResponseAsync(
                        DiscordInteractionResponseType.ChannelMessageWithSource,
                        new DiscordInteractionResponseBuilder()
                            .WithContent("An error occurred while processing your submission. Please try again.")
                            .AsEphemeral()
                    );
                }
                catch
                {
                    // Response was already sent, ignore
                }

                return Result.Failure($"Failed to handle modal submission: {ex.Message}");
            }
        }

        private static async Task<Result> HandleDeckSubmissionAsync(DiscordInteraction interaction, string customId)
        {
            // Parse match ID and game number from custom ID: "submit_deck_{matchId}_{gameNumber}"
            var parts = customId.Replace("submit_deck_", "", StringComparison.Ordinal).Split('_');
            if (
                parts.Length < 2
                || !Guid.TryParse(parts[0], out var matchId)
                || !int.TryParse(parts[1], out var gameNumber)
            )
            {
                await interaction.CreateResponseAsync(
                    DiscordInteractionResponseType.ChannelMessageWithSource,
                    new DiscordInteractionResponseBuilder()
                        .WithContent("Invalid match or game information.")
                        .AsEphemeral()
                );
                return Result.Failure("Invalid match or game information");
            }

            // Get deck code from modal text input (assuming component ID "deck_code")
            // Note: In DSharpPlus 5.0, modal components are in interaction.Data.Components
            var deckCode = string.Empty; // TODO: Extract from modal submission data properly

            if (string.IsNullOrWhiteSpace(deckCode))
            {
                await interaction.CreateResponseAsync(
                    DiscordInteractionResponseType.ChannelMessageWithSource,
                    new DiscordInteractionResponseBuilder().WithContent("Deck code cannot be empty.").AsEphemeral()
                );
                return Result.Failure("Deck code cannot be empty");
            }

            await interaction.CreateResponseAsync(DiscordInteractionResponseType.DeferredMessageUpdate);

            // Publish PlayerDeckSubmitted (DiscBot-local) for App to handle
            await DiscBotService.PublishAsync(
                new PlayerDeckSubmitted(matchId, gameNumber, interaction.User.Id, deckCode)
            );

            return Result.CreateSuccess("Deck submitted");
        }

        private static async Task<Result> HandleDeckConfirmAsync(DiscordInteraction interaction, string customId)
        {
            // Parse match ID and game number from custom ID: "confirm_deck_{matchId}_{gameNumber}"
            var parts = customId.Replace("confirm_deck_", "", StringComparison.Ordinal).Split('_');
            if (
                parts.Length < 2
                || !Guid.TryParse(parts[0], out var matchId)
                || !int.TryParse(parts[1], out var gameNumber)
            )
            {
                await interaction.CreateResponseAsync(
                    DiscordInteractionResponseType.ChannelMessageWithSource,
                    new DiscordInteractionResponseBuilder()
                        .WithContent("Invalid match or game information.")
                        .AsEphemeral()
                );
                return Result.Failure("Invalid match or game information");
            }

            // TODO: Retrieve current deck code from DM message state or cache
            var deckCode = string.Empty; // Placeholder

            await interaction.CreateResponseAsync(DiscordInteractionResponseType.DeferredMessageUpdate);

            // Publish PlayerDeckConfirmed (DiscBot-local) for App to handle
            await DiscBotService.PublishAsync(
                new PlayerDeckConfirmed(matchId, gameNumber, interaction.User.Id, deckCode)
            );

            return Result.CreateSuccess("Deck confirmed");
        }

        #region Rendering Requests
        /// <summary>
        /// Handles game container creation requests by extracting Discord context and calling the Renderer.
        /// </summary>
        private static async Task<Result> HandleGameContainerRequestedAsync(GameContainerRequested evt)
        {
            try
            {
                var client = DiscordClientProvider.GetClient();

                var matchResult = await CoreService.Matches.GetByIdAsync(evt.MatchId, DatabaseComponent.Repository);
                if (!matchResult.Success)
                {
                    return Result.Failure("Match not found");
                }
                var validationResult = await MatchCore.Validation.ValidateMatch(matchResult.Data);
                if (!validationResult.Success)
                {
                    return Result.Failure(
                        validationResult.ErrorMessage ?? "Match validation failed missing ErrorMessage"
                    );
                }

                var match = matchResult.Data!;
                var channel = await client.GetChannelAsync(match.ChannelId!.Value);
                var team1thread = await client.GetChannelAsync(match.Team1ThreadId!.Value) as DiscordThreadChannel;
                var team2thread = await client.GetChannelAsync(match.Team2ThreadId!.Value) as DiscordThreadChannel;

                if (channel is null)
                {
                    return Result.Failure("Match channel not found");
                }
                if (team1thread is null)
                {
                    return Result.Failure("Match team 1 thread not found");
                }
                if (team2thread is null)
                {
                    return Result.Failure("Match team 2 thread not found");
                }

                var containerResult = await Renderers.GameRenderer.RenderGameContainerAsync(
                    client,
                    channel,
                    team1thread,
                    team2thread,
                    evt.MatchId,
                    evt.GameNumber,
                    evt.ChosenMap
                );

                if (!containerResult.Success)
                {
                    return Result.Failure($"Failed to create game container: {containerResult.Message}");
                }
                return Result.CreateSuccess(containerResult.Message);
            }
            catch (Exception ex)
            {
                await DiscBotService.ErrorHandler.CaptureAsync(
                    ex,
                    $"Failed to handle game container request for match {evt.MatchId}, game {evt.GameNumber}",
                    nameof(HandleGameContainerRequestedAsync)
                );
                return Result.Failure($"Failed to create game container: {ex.Message}");
            }
        }

        /// <summary>
        /// Handles deck DM start requests by extracting Discord context and calling the Renderer.
        /// </summary>
        private static async Task<Result> HandleDeckDmStartRequestedAsync(DeckDmStartRequested evt)
        {
            try
            {
                var client = DiscordClientProvider.GetClient();
                var user = await client.GetUserAsync(evt.PlayerDiscordUserId);

                if (user is null)
                {
                    await DiscBotService.ErrorHandler.CaptureAsync(
                        new InvalidOperationException($"User {evt.PlayerDiscordUserId} not found"),
                        "Cannot send deck DM - user not found",
                        nameof(HandleDeckDmStartRequestedAsync)
                    );
                    return Result.Failure("User not found");
                }

                // Call renderer with concrete parameters
                return await Renderers.GameRenderer.RenderDeckDmStartAsync(client, user, evt.MatchId, evt.GameNumber);
            }
            catch (Exception ex)
            {
                await DiscBotService.ErrorHandler.CaptureAsync(
                    ex,
                    $"Failed to handle deck DM start request for match {evt.MatchId}, game {evt.GameNumber} to player {evt.PlayerDiscordUserId}",
                    nameof(HandleDeckDmStartRequestedAsync)
                );
                return Result.Failure($"Failed to send deck DM: {ex.Message}");
            }
        }

        /// <summary>
        /// Handles deck DM update requests by extracting Discord context and calling the Renderer.
        /// </summary>
        private static async Task<Result> HandleDeckDmUpdateRequestedAsync(DeckDmUpdateRequested evt)
        {
            try
            {
                // TODO: Implement when message tracking is available
                return Result.CreateSuccess("Deck DM update placeholder");
            }
            catch (Exception ex)
            {
                await DiscBotService.ErrorHandler.CaptureAsync(
                    ex,
                    $"Failed to handle deck DM update request for match {evt.MatchId}, game {evt.GameNumber}, player {evt.PlayerId}",
                    nameof(HandleDeckDmUpdateRequestedAsync)
                );
                return Result.Failure($"Failed to update deck DM: {ex.Message}");
            }
        }

        /// <summary>
        /// Handles deck DM confirm requests by extracting Discord context and calling the Renderer.
        /// </summary>
        private static async Task<Result> HandleDeckDmConfirmRequestedAsync(DeckDmConfirmRequested evt)
        {
            try
            {
                // TODO: Implement when message tracking is available
                return Result.CreateSuccess("Deck DM confirm placeholder");
            }
            catch (Exception ex)
            {
                await DiscBotService.ErrorHandler.CaptureAsync(
                    ex,
                    $"Failed to handle deck DM confirm request for match {evt.MatchId}, game {evt.GameNumber}, player {evt.PlayerId}",
                    nameof(HandleDeckDmConfirmRequestedAsync)
                );
                return Result.Failure($"Failed to confirm deck DM: {ex.Message}");
            }
        }

        #endregion
    }
}
